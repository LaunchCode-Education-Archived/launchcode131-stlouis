<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Vectors and Points | LaunchCode's CSE131</title>
  <meta name="description" content="">

  <link rel="stylesheet" href="/launchcode131-stlouis/css/main.css">
  <link rel="canonical" href="https://education.launchcode.org/launchcode131-stlouis/launchcode131-stlouis/weeks/7/assignment/">
  <link rel="alternate" type="application/rss+xml" title="LaunchCode's CSE131" href="https://education.launchcode.org/launchcode131-stlouis/launchcode131-stlouis/feed.xml">
</head>


<body>
	<div class="wrapper writeup">
			<div class="container">
				<nav class="site-nav">
					<a href="../">&larr; Week 7 Overview</a>
				</nav>

				<article class="site-content">
					<h1>Assignment 7: Vectors and Points</h1>

					 
					<aside class="sidenote">
						<h2 class="nocount">Logistics</h2>
						<p><strong>Assigned:</strong> Mon, Jul 25</p>
						<p><strong>Due:</strong> Mon, Aug 1</p>
					</aside>
					

					<ul id="markdown-toc">
  <li><a href="#creating-vector-and-point-class" id="markdown-toc-creating-vector-and-point-class">Creating <code class="highlighter-rouge">Vector</code> and <code class="highlighter-rouge">Point</code> class</a>    <ul>
      <li><a href="#part-i-implementing-a-vector-class" id="markdown-toc-part-i-implementing-a-vector-class">Part I. Implementing a Vector class:</a></li>
      <li><a href="#part-ii-a-point-class" id="markdown-toc-part-ii-a-point-class">Part II: A Point Class</a></li>
    </ul>
  </li>
</ul>

<h1 id="creating-vector-and-point-class">Creating <code class="highlighter-rouge">Vector</code> and <code class="highlighter-rouge">Point</code> class</h1>

<p>In Part I, you will define a Java class that models a mathematical vector. Part II involves writing methods that implement a point.</p>

<p>You are encouraged to work on Parts I and II using <a href="http://en.wikipedia.org/wiki/Test-driven_development">test-driven development</a>.</p>

<blockquote>
  <p>Test-driven development means that the code you write is governed by the tests your code has to pass. For this lab, you are provided a <code class="highlighter-rouge">VectorAndPointTest</code> JUnit test case.  You will use the test methods in that file to drive your implementation of <code class="highlighter-rouge">Vector</code>.</p>

  <p>You will follow this same methodology as you develop your <code class="highlighter-rouge">Point</code> class.</p>
</blockquote>

<h2 id="part-i-implementing-a-vector-class">Part I. Implementing a Vector class:</h2>

<p>A vector is a mathematical description of a direction and a magnitude (using
a polar-coordinate representation).
Another way to think about a vector is a location relative to some point
of origin.  In other words, a vector is a displacement horizontally
and vertically from some point of origin.</p>

<p>If you think about them this way, you can see how vectors can
be added, as shown below.</p>

<p><img src="../../../assignments/vectors.gif" alt="vectors" /></p>

<ol>
  <li>Open the file <code class="highlighter-rouge">VectorAndPointTest.java</code> and take a look
 at the JUnit tests that appear in the file.
    <ul>
      <li>
        <p>You are to proceed with the development of your <code class="highlighter-rouge">Vector</code> class by considering these tests one at a time.  For example, the <code class="highlighter-rouge">init()</code> test will require you to write the constructor for <code class="highlighter-rouge">Vector</code>.</p>

        <ul>
          <li>
            <p>You will have red flags because <code class="highlighter-rouge">Vector</code> is not yet complete, but you can run the JUnit test nonetheless.  If you expand the <code class="highlighter-rouge">lab7.VectorAndPointTest</code> in the JUnit window, you can see which tests are passing or not. Clicking on a given test shows you the detail below in the Failure Trace window.</p>
          </li>
          <li>
            <p>A green checkmark indicates success;  a dark X indicates failure;  a red X indicates compilation problems not yet addressed.</p>
          </li>
        </ul>
      </li>
      <li>
        <p>After that, the <code class="highlighter-rouge">arith()</code> test would have you implement <code class="highlighter-rouge">Vector</code>’s <code class="highlighter-rouge">plus</code> and <code class="highlighter-rouge">minus</code> methods.</p>
      </li>
      <li>
        <p><strong>As you follow the instructions below, develop and then test each method one at a time!</strong>  Read through the instructions before and during your develpment to guide your writing of the <code class="highlighter-rouge">Vector</code> class.</p>
      </li>
    </ul>
  </li>
  <li>
    <p>Open <code class="highlighter-rouge">Vector</code> in the provided <code class="highlighter-rouge">lab7</code> package. A class named <code class="highlighter-rouge">Vector</code> has been defined in the file, but so far it contains
 no instance variables or methods. (Notice that the class name exactly
 matches the file name, including capitalization. Java requires this.)</p>
  </li>
  <li>
    <p><strong>Instance variables:</strong> The instance variables of a class define what kind of information
 each object of that class will hold.
 If we think of a vector as a translation in two-dimensional space,
 then we can represent a vector as
 the change in x and the change in y.
 In other words, we want each Vector object to contain two distances,
 deltaX and deltaY.</p>

    <blockquote>
      <p>To accomplish this,
declare two instance variables in the Vector class, and name them
deltaX and deltaY.  Both should be of type <code class="highlighter-rouge">double</code>.</p>
    </blockquote>

    <p><strong>Naming conventions:</strong></p>

    <p>By convention,
 names of instance variables and methods should begin with lower case
 letters, to distinguish them from class names, which begin with upper
 case letters.  If a variable has multi-word name, we usually
 capitalize subsequent words. For example, <code class="highlighter-rouge">thisIsAVeryLongVariableName</code>.</p>

    <p><strong>Encapsulation:</strong></p>

    <p>Objects usually contain data, and it is good
 design practice to make sure that this data can’t be “messed with” by
 other classes.  Other classes should call methods on the object to
 access the information.  That way, each class can control what is seen
 and, more importantly, how it is modified.</p>

    <blockquote>
      <p>Make both of the instance variables in your Vector class <b>private</b> by typing the keyword <code class="highlighter-rouge">private</code> at the beginning of the declaration, before the type of variable.</p>
    </blockquote>

    <p>When you make the variables private, Java will make sure
 that the only way that code in other classes can see or modify their
 values is by calling methods of the Vector class.</p>
  </li>
  <li>
    <p><strong>Initialization:</strong></p>

    <p>Assigning to a variable for the first time is called “initializing” the variable.
 Constructurs usually have the job of initializing instance variables.
 When we create Vector objects, we will probably want to supply the
 deltaX and deltaY values for them.  So, define a public constructor 
 that takes two double parameters and assigns their values to deltaX and deltaY.
 Recall that a constructor always has the same name as the class.</p>

    <blockquote>
      <p>Tip: You can type the constructor yourself if you want, but Eclipse provides
some tools for generating these kinds of constructors automatically.  To create the
constructor automatically, first position your text cursor on the class name at the beginning of the file.  Then open the Source menu and select “Generate constructor using fields.”
Finally, select the boxes for deltaX and deltaY so that the constructor will have parameters
that are used to initialize those instance variables.</p>
    </blockquote>

    <p><strong>Name masking:</strong> A method or constructor may have a parameter
 whose name is the same as the name of an instance variable.
 For example, you might have a parameter and instance variable both with the name “deltaX.”
 When a name is used in a program, it refers to the “closest” declaration.
 So any use of the name “deltaX” would refer to the parameter.  In this case, we say that the
 parameter <b>masks</b> the instance variable.
 But inside the method or constructor, we may still want to use or change the value of the
 instance variable.
 Within a method, the keyword <code class="highlighter-rouge">this</code>
 always refers to the object on which the method has been invoked
 (i.e., “this” object).  When an instance variable is masked, you can
 still refer to it by preceding its name with “<code class="highlighter-rouge">this</code>.” For
 example, inside the method, <code class="highlighter-rouge">this.deltaX = deltaX</code> will assign
 the value of the parameter deltaX to the instance variable named
 deltaX inside “this” object.</p>

    <p><strong>Implicit targets:</strong> Normally, when you call a method on a target
 object, you identify the target, and then identify the method and its
 actual parameters.  For example,</p>

    <p><code class="highlighter-rouge">alice.deposit(50)</code></p>

    <p>calls the deposit method on the object to which <code class="highlighter-rouge">alice</code> refers.
 In other words, <code class="highlighter-rouge">alice</code> is the target.  If you don’t identify a
 target, then it is assumed that the target is the same object that is
 currently executing a method.  For example, if we call the
 deposit method on <code class="highlighter-rouge">alice</code> and inside of the deposit method
 there is an expression <code class="highlighter-rouge">getBalance()</code>, then it is understood
 that the method will be called on <tt>alice</tt> since that is the
 object in which the deposit method is executing.  In such cases, it is not
 necessary (and considered bad style) to use the word “this” because it
 is already understood that this object is the target.</p>
  </li>
  <li>
    <p><strong>The toString method:</strong></p>

    <p>It is customary to provide a method called
 <code class="highlighter-rouge">toString</code> that takes no parameters and returns a <code class="highlighter-rouge">String</code>
 value that is a textual description of the object.  You can call this
 method yourself, but  Java will also call it whenever it needs to
 concatenate the object onto a String.  Define a <code class="highlighter-rouge">toString</code>
 method for the Vector class that returns a textual description of the
 vector. For example, <code class="highlighter-rouge">(new Vector(4,3)).toString()</code> might
 have the value <code class="highlighter-rouge">"[4 3]"</code> as its return value.  (Hint: Form this
 string by concatenating various characters with the deltaX and deltaY
 values.)</p>
  </li>
  <li>
    <p><strong>Accessors:</strong></p>

    <p>Most classes provide <strong><em>accessor</em></strong> methods that
 other parts of a program can call to get information from an object.  For
 the Vector class, define two accessor methods named <code class="highlighter-rouge">getDeltaX</code>
 and <code class="highlighter-rouge">getDeltaY</code> that take no parameters and return the values
 of the instance variables deltaX and deltaY, respectively. Note: Here,
 the instance variables will not be masked by matching parameter names
 (in fact, there are no parameters at all), so there is no need to use
 “this.” You can refer to the instance variables by their names
 alone.</p>

    <blockquote>
      <p>Tip: You can type the methods yourself, or you can open the Eclipse
Source menu and select “Generate Getters and Setters.”  Check the boxes for “getDeltaX” and
“getDeltaY.” Study the methods after creating them.</p>
    </blockquote>

    <p>At this point, your <code class="highlighter-rouge">VectorAndPointTest</code> JUnit test should pass its <code class="highlighter-rouge">init()</code> test.</p>
  </li>
  <li>
    <p><strong>Accessors that compute their return value:</strong>
 Sometimes accessors provide information that is not directly
 stored inside the object, but is instead computed when the method is
 called.  For example, write a method
 called <code class="highlighter-rouge">magnitude</code> that takes no parameters and returns a
 <code class="highlighter-rouge">double</code>, the length of the vector.  Use the pythagorean theorem to compute the length of the vector.  Recall that the method <code class="highlighter-rouge">Math.sqrt(x)</code> returns the square root of x.</p>
  </li>
  <li>
    <p><strong>Mutators and immutable objects:</strong> Often, a class will provide <strong><em>mutator</em></strong> methods, such as
 <code class="highlighter-rouge">setDeltaX</code>, that allow controlled modification of the data
 stored in the corresponding instance variables.  However, we will
 <strong>not</strong> provide mutators for the Vector class.  Instead, each of
 our Vector objects will be <em>immutable</em>, meaning that once it is
 created, its value will never change.  So, whenever we want a Vector
 with a different direction or magnitude, we will have to create a new object.</p>

    <p>Since Vector objects will be immutable, the rest of these methods will create <em>new</em> vectors as their return values. They’ll do this by first computing the desired deltaX and deltaY values, and then using the Java keyword <code class="highlighter-rouge">new</code> to call the constructor you wrote earlier.  You can define local variables inside the methods whenever it’s convenient, but remember that the final result of each method will be a new vector.  Don’t modify the object on which the method was called.</p>

    <blockquote>
      <p><em>Note:</em> You may want to add the word <strong>final</strong> to the
declaration of your instance variables.  This indicates that the instance
variable’s value should be established by the constructor and not be
changed by any other method.  Adding <strong>final</strong> will prevent you from
accidentally changing the value in the methods you write for the
<code class="highlighter-rouge">Vector</code> class.</p>
    </blockquote>
  </li>
  <li>
    <p>Define a method called <code class="highlighter-rouge">deflectX</code> that takes no parameters and returns a new vector that is
 identical to “this” one, except that its
 deltaX component has the opposite sign.
 For example, if this vector is [-3 4], then 
 the new vector would be [3 4].  In other words,
 the method creates a vector oriented in the opposite x direction.</p>
  </li>
  <li>
    <p>Define a method called <code class="highlighter-rouge">deflectY</code> that takes no parameters and returns a new vector that is
identical to “this” one, except that its
deltaY component has the opposite sign.</p>
  </li>
  <li>
    <p>Define a method called
<code class="highlighter-rouge">plus</code> that takes another vector as its parameter and returns
a new vector that is the sum of this vector and the one
provided as input. Recall that to add two vectors, you add their x-coordinates
and their y-coordinates. For example, suppose you have a vector
with value [3 4] and you call the <code class="highlighter-rouge">plus</code> method on it, passing in
a vector with value [-5 2]. Then the vector returned by the
method should have the value [-2 6].</p>

    <p>Hint: The parameter type and return
type of this method are both Vector.  When you create the new
vector to be returned, you will need to supply parameter values.
To compute those parameter values, you can
use both “this” vector (the one on which the method was called) and
the vector that was passed in as a parameter.</p>
  </li>
  <li>
    <p>Define a method called
<code class="highlighter-rouge">minus</code> that takes another vector as its parameter and returns
a <strong>new</strong> vector that is the difference of this vector minus
the one provided as input.</p>

    <blockquote>
      <p><em>Challenge:</em> Write <code class="highlighter-rouge">minus</code> in terms of methods you
have already defined for the <code class="highlighter-rouge">Vector</code> class.  Which
computer science principle are you applying by doing that?</p>
    </blockquote>

    <p>At this point, your <code class="highlighter-rouge">VectorAndPointTest</code> JUnit test should also pass its <code class="highlighter-rouge">arith()</code> test.</p>
  </li>
  <li>
    <p>Define a method called
<code class="highlighter-rouge">scale</code> takes a <code class="highlighter-rouge">double</code> named
<code class="highlighter-rouge">factor</code> as its parameter.  When you call this method on
a vector, it should return a new vector whose
direction is the same, but whose magnitude has been multiplied by the given
parameter.</p>

    <blockquote>
      <p><em>Recall:</em> Scaling a vector by some <code class="highlighter-rouge">factor</code>
can be accomplished by scaling its <code class="highlighter-rouge">deltaX</code> and <code class="highlighter-rouge">deltaY</code>
components by that same factor.  Be sure to return a <em>new</em> vector,
and don’t change the one on which this method was called.</p>
    </blockquote>

    <p>At this point, your <code class="highlighter-rouge">VectorAndPointTest</code> JUnit test should also pass the <code class="highlighter-rouge">testScaleAndDeflect()</code> test.</p>
  </li>
  <li>
    <p>Define a method called
<code class="highlighter-rouge">rescale</code> takes a double named
<code class="highlighter-rouge">magnitude</code> as its parameter.  When you call this method on
a vector, it should return a new vector whose
direction is the same, but whose magnitude is the one supplied as the
parameter.</p>

    <blockquote>
      <p><em>Hint:</em> First call the <code class="highlighter-rouge">magnitude</code> method to find this vector’s magnitude and save it in a local variable.
Use this to compute a scale factor, and then let the <code class="highlighter-rouge">scale</code> method do the rest of the work.</p>
    </blockquote>

    <p><strong>NOTE:</strong> If the target of the rescale method has a zero magnitude, no particular direction is defined for the resulting vector.  One could consider this an error condition, but for the purposes of this assignment, if the original magnitude is zero, let the resulting vector have deltaX equal to the given magnitude, and deltaY equal zero.</p>
  </li>
</ol>

<p>At this point, make sure your code passes <em>all</em> the <code class="highlighter-rouge">VectorAndPointTest</code> cases
provided with this lab.  Do NOT change the test code (we are watching and will know if 
the revision changes on that file).</p>

<h2 id="part-ii-a-point-class">Part II: A Point Class</h2>

<blockquote>
  <p><strong>Note:</strong> You are encouraged to develop <code class="highlighter-rouge">Point</code> as you did
<code class="highlighter-rouge">Vector</code>, using test-driven development.</p>
</blockquote>

<ol>
  <li>
    <p>In the Package Explorer, select the <code class="highlighter-rouge">lab7</code> package and use the File menu to create a new class named <code class="highlighter-rouge">Point</code> in that package.  In the Point.java file that is created, write an implementation according to the specificaion described in the following steps, <strong>testing as you go</strong>.</p>
  </li>
  <li>
    <p><strong>Instance variables:</strong> Since a point is just an (x,y) pair, declare two instance variables (of type <code class="highlighter-rouge">double</code>) to hold the x and y coordinates of the point.  These variables should be private to prevent changes from outside. The constructor and all methods in this class should be public.</p>
  </li>
  <li>
    <p><strong>Constructor:</strong> Write a constructor that takes <code class="highlighter-rouge">x</code> and <code class="highlighter-rouge">y</code> as parameters, and initializes the new Point object with the values that are passed in.</p>
  </li>
  <li>
    <p><strong>Accessors:</strong> Create getX and getY methods that return the coordinate values.</p>
  </li>
  <li>
    <p><strong>toString:</strong> Write a toString method that returns a String representation of the point.  For example, if x is 3 and y is -2, you might return the String “<code class="highlighter-rouge">(3.0, -2.0)</code>”.</p>
  </li>
  <li>
    <p><strong>Adding a Vector to a Point:</strong>  It doesn’t make sense to add two points together, but it does make sense to add a vector to a point.  The result is a new point that differs from the old point by the deltaX and deltaY of the vector.  For example, if we have the point (3,-2) and we add the vector [4 1], we will get the point (7,-1).  Write a <code class="highlighter-rouge">plus</code> method of the Point class that takes a Vector as a paramter and creates a new point that results from adding this point to the given vector.</p>
  </li>
  <li>
    <p><strong>Subtracting Points:</strong> When you subtract one point from
 another, you get a Vector, as shown in the figure below.  As an
 example, suppose point P is (4,2) and suppose that point Q is (1,6),
 then P-Q would be the vector [3 -4].
 (To see why this makes sense, consider what point you would get by adding the vector to Q.)</p>

    <p><img src="../../../assignments/subtracting-points.jpg" alt="image" /></p>

    <p>Write a <code class="highlighter-rouge">minus</code> method of the Point class that takes another Point as its parameter and returns the appropriate vector.</p>
  </li>
  <li>
    <p><strong>Distance to another point:</strong> Write a method 
 named <code class="highlighter-rouge">distance</code> that takes another point as a parameter and returns the distance between this point and the given point.</p>

    <blockquote>
      <p>Try to implement this by <strong>reducing</strong> this problem to calls of
methods you have already written.</p>
    </blockquote>
  </li>
  <li>
    <p><strong>Make sure your code passes the unit tests.</strong></p>
  </li>
</ol>


				</article>
			</div>

			<footer class="site-footer">
	<p>
		<small>Generated at  2016-07-26 14:59:32 -0500</small>.
	</p>
	<p>
		<small>
			Page written by (unknown).
			Site design by <a href="http://ben.stolovitz.com">Ben Stolovitz</a>.
		</small>
	</p>
</footer>

	</div>
	<script type="text/javascript" src="/launchcode131-stlouis/js/highlight.pack.js"></script>
	<script type="text/x-mathjax-config">
		hljs.initHighlightingOnLoad();
		MathJax.Hub.Config({
		tex2jax: {
			inlineMath: [ ["$", "$"], ["\\(", "\\)"] ],
			processEscapes: true
		}
		});
	</script>
	<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
</body>
</html>